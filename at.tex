\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[all]{xy}
\usepackage{bigfoot}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{verbatim}
\usepackage{xcolor}
\usepackage{minted}
\usepackage{amsthm}
\usepackage{enumitem,amssymb}

\newlist{todolist}{itemize}{1}
\setlist[todolist]{label=$\square$}

\theoremstyle{definition}
\newtheorem{definition}{Definizione}[section]
\newtheorem{example}{Esempio}[subsection]
\newtheorem{exercise}{Esercizio}[subsection]
\newtheorem{observation}{Osservazione}[subsection]

\newenvironment{boxed}
    {\begin{center}
    \begin{tabular}{|p{0.9\textwidth}|}
    \hline\\
    }
    {
    \\\\\hline
    \end{tabular}
    \end{center}
    }

\definecolor{LightGray}{rgb}{0.98,0.98,0.98}
\newminted{typescript}{fontfamily=tt,bgcolor=LightGray}

\newenvironment{code}
  {\vspace{0.5cm} \VerbatimEnvironment\begin{typescriptcode}}
  {\end{typescriptcode} \vspace{0.2cm}}

\title{Writing strongly typed code in TypeScript}
\author{Giulio Canti}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Introduzione}

Questo corso mira ad esporre una serie di tecniche per sfruttare al massimo la \emph{type safety} che offre il linguaggio TypeScript.

\begin{quote}
Type safe usually refers to languages that ensure that an operation is working on the right kind of data at some point
before the operation is actually performed. This may be at compile time or at runtime.
\end{quote}

\textbf{Obbiettivo} (ambizioso): eliminare gli errori a runtime

\begin{tikzpicture}
  \draw[->] (0,0) -- (6,0) node[right] {sforzo};
  \draw[->] (0,0) -- (0,3) node[above] {type safety};
  \draw[scale=2,domain=0:1.4,smooth,variable=\x,black]  plot ({\x*\x*\x},{\x});
\end{tikzpicture}

\subsection{Prerequisiti}

\begin{itemize}
  \item \texttt{node} e \texttt{npm}
  \item \texttt{typescript@3.2.2+}
  \item \texttt{typings-checker@2.0.0+}
  \item \texttt{tsconfig.json}
    \begin{itemize}
      \item \texttt{"strict": true}
      \item (consigliato) \texttt{"noImplicitAny": true}
    \end{itemize}
  \item \texttt{ts-node@6.0.4+}
  \item (consigliato) \texttt{prettier@1.15.2+}
  \item (consigliato) \texttt{VS Code}
\end{itemize}

\begin{verbatim}
npm i -g typescript@latest ts-node@latest
git clone https://github.com/gcanti/typescript-course.git
cd typescript-course
npm install
\end{verbatim}

\subsection{Come eseguire gli esercizi del corso}

Gli esercizi sono contenuti nella cartella \texttt{src}. Una volta svolto un esercizio è possibile controllarne
il risultato eseguendo il seguente comando da terminale

\begin{verbatim}
npm test -- src/<file>
\end{verbatim}

per gli esercizi che riguardano la programmazione type level, oppure

\begin{verbatim}
ts-node src/<file>
\end{verbatim}

per gli altri.

Se non viene sollevata alcuna eccezione la soluzione è da considerarsi corretta.

\begin{observation}
Le soluzioni fornite nel repository \texttt{typescript-course} costituiscono solo un punto di referimento, in generale \textbf{gli esercizi possono ammettere più di una soluzione corretta}.
\end{observation}

\subsection{Il type system di TypeScript è strutturale}

\begin{quote}
TypeScript is a structural type system. When we compare two different types, regardless of where they came from,
if the types of all members are compatible, then we say the types themselves are compatible. - Documentazione ufficiale
\end{quote}

\begin{example}
Due classi sono compatibili se sono compatibili i loro campi

\begin{code}
class A {}

class B {}

class C {
  constructor(public value: number) {}
}

declare function f(a: A): void

f(new A())
f(new B())
f(new C(1))
f({})
f(f)

declare function g(c: C): void

g(new C(1))
g(new A()) // error
\end{code}
\end{example}

\subsection{Funzioni parziali}

\begin{definition}
Una funzione \emph{parziale} $f: X \rightarrow Y$ è una funzione che non è definita per tutti i valori del suo dominio $X$
($Y$ è chiamato il codominio).
\end{definition}

Viceversa una funzione definita per tutti i valori del dominio è detta \emph{totale}.

\begin{example}
$$
f(x) = \frac{1}{x}
$$
\end{example}

La funzione $f: number \rightarrow number$ non è definita per $x = 0$.

\begin{example}
La funzione \texttt{head}

\begin{code}
// il codominio di questa funzione dovrebbe
// essere number | undefined ma il type-checker
// non mi avverte!
const head = (xs: Array<number>): number => {
  return xs[0]
}

const x: number = head([]) // no error
\end{code}
\end{example}

\begin{example}
La funzione \texttt{readFileSync}

\begin{code}
import * as fs from "fs"

// should return `string`
fs.readFileSync("", "utf8")
// throws "no such file or directory" instead
\end{code}
\end{example}

\begin{observation}
Il problema più grosso nel lanciare eccezioni è che questo fatto non si riflette nella firma della funzione,
quindi il comportamento reale della funzione non è codificato a livello del type system di TypeScript.
\end{observation}

Una funzione parziale $f: X \rightarrow Y$ può essere sempre ricondotta ad una funzione totale $f'$ aggiungendo un valore speciale,
chiamiamolo $None \notin Y$, al codominio e associandolo ad ogni valore di $X$ per cui $f$ non è definita

$$
f': X \rightarrow Y \cup None
$$

Chiamiamo $Option(Y)$ l'insieme $Y \cup None$.

$$
f': X \rightarrow Option(Y)
$$

Torneremo a parlare del tipo \texttt{Option} più avanti.

\begin{boxed}
Quando possibile, cercate di definire funzioni totali
\end{boxed}

\subsection{Strutture dati immutabili}

In TypeScript usare strutture dati \textbf{mutabili} può condurre ad errori a runtime

\begin{code}
const xs: Array<string> = ["foo", "bar"]
const ys: Array<string | undefined> = xs
ys.push(undefined)
xs.map(s => s.trim())
// runtime error:
// Cannot read property 'trim' of undefined
\end{code}

\begin{boxed}
Quando possibile, cercate di usare strutture dati immutabili
\end{boxed}

\subsection{Il tipo \texttt{object}}

Il tipo \texttt{object} rappresenta tutti i valori meno quelli primitivi

\begin{code}
const x1: object = { foo: "bar" }
const x2: object = [1, 2, 3]
const x3: object = 1 // error
const x4: object = "foo" // error
const x5: object = true // error
const x6: object = null // error
const x7: object = undefined // error
\end{code}

\subsection{I tipi \texttt{any}, \texttt{never} e \texttt{unknown}}

Se pensiamo ai tipi come insiemi, allora gli \emph{abitanti} di un tipo sono gli elementi di quell'insieme.

\begin{code}
// gli abitanti sono tutte le stringhe
type A = string

// gli abitanti sono tutti i numeri
type B = number

// questo è un "literal type" e contiene un solo abitante:
// la stringa "foo"
type C = "foo"

// quanti abitanti ha questo tipo?
type D = 0 | 1
\end{code}

\begin{definition}
Un tipo \texttt{A} si dice \emph{sottotipo} di un tipo \texttt{B} se ogni abitante di \texttt{A} è abitante di \texttt{B}.

Si dice \emph{supertipo} se vale la proprietà inversa.
\end{definition}

\begin{example}
Il tipo \texttt{C} è sottotipo del tipo \texttt{string}.
Il tipo \texttt{number} è supertipo del tipo \texttt{D}
\end{example}

\begin{exercise}
In che relazione sono i seguenti tipi?

\begin{code}
type T1 = { a: string }
type T2 = { b: number, a: string }
\end{code}

\begin{todolist}
\item \texttt{T1} è sottotipo di \texttt{T2}
\item \texttt{T2} è sottotipo di \texttt{T1}
\item nessuno dei due
\end{todolist}

\begin{code}
type T3 = { a: string, b: boolean }
type T4 = { b: number, a: string }
\end{code}

\begin{todolist}
\item \texttt{T3} è sottotipo di \texttt{T4}
\item \texttt{T4} è sottotipo di \texttt{T3}
\item nessuno dei due
\end{todolist}
\end{exercise}

\begin{definition}
Un tipo \texttt{X} si dice \emph{bottom type} se è sottotipo di ogni altro tipo
\end{definition}

Il tipo \texttt{never} non contiene abitanti ed è un \emph{bottom type}.

\begin{code}
const raise = (message: string): never => {
  throw new Error(message)
}

const absurd = <A>(x: never): A => {
  return raise("absurd")
}
\end{code}

\begin{definition}
Un tipo \texttt{X} si dice \emph{top type} se è supertipo di ogni altro tipo
\end{definition}

Il tipo \texttt{any} è sia \emph{top type} sia \emph{bottom type}.
Viene usato per "disabilitare" il type-checker (a volte risulta necessario).
Usatelo con parsimonia.

\begin{observation}
Un problema di \texttt{any} è che non è adatto a rappresentare \emph{input non validati}
\end{observation}

\begin{example}
\texttt{JSON.parse} è unsafe dato che il tipo di ritorno è \texttt{any}.

\begin{code}
const payload = `{"a":1}`
const x = JSON.parse(payload)
// `x` è di tipo `any`
x.bar.trim() // runtime error:
// Cannot read property 'trim' of undefined
\end{code}
\end{example}

Dalla \texttt{3.0.1} una possibile soluzione è utilizzare il tipo \texttt{unknown}.

Il tipo \texttt{unknown} è un top type ma \textbf{non è} un bottom type.

Per poter utilizzare un valore di tipo \texttt{unknown} occorre \emph{raffinarlo}

\begin{example}
Un \texttt{JSON.parse} type safe (o quasi \footnote{può lanciare eccezioni})

\begin{code}
export const parse: (input: string) => unknown = JSON.parse

const payload = `{"bar":"foo"}`
const x = parse(payload)
x.bar // static error: Object is of type 'unknown'
\end{code}
\end{example}

\begin{observation}
Ridefinire il tipo di una funzione può essere fatto in modo che non ci sia alcun costo a runtime.
\end{observation}

\emph{Raffinare} un valore vuol dire scrivere del codice specifico che permette di provare al type checker
alcune caratteristiche sul tipo del valore

\begin{code}
if (typeof x === 'object') {
  // x ha tipo object | null
  if (x !== null) {
    // x ha tipo object
    const bar = (x as { [key: string]: unknown }).bar
    if (typeof bar === 'string') {
      // bar ha tipo string
      console.log(bar.trim())
    }
  }
}
\end{code}

Vedremo più avanti come sia possibile eliminare il boilerplate utilizzando le \emph{custom type guard}.

\newpage

\section{Tour delle feature avanzate}

\subsection{Inline declarations}

Le dichiarazione all'interno del codice invece che nei \textbf{definition file}
\footnote{I definition file costituiscono un ponte tra il mondo untyped di JavaScript e quello types di TypeScript}
sono particolarmente utili quando si stia esplorando
una soluzione e per fare velocemente delle prove di type checking.

\begin{example}
Costanti, variabili, funzioni e classi

\begin{code}
// costanti
declare const a: number

// variabili
declare let b: number

// funzioni
declare function f(x: string): number
declare const g: (x: string) => number

// classi
declare class Foo {
  public value: string
  constructor(value: string)
}
\end{code}
\end{example}

In molti degli esercizi sfrutteremo questa feature lavorando solo sulle dichiarazioni invece di preoccuparci dell'implementazione.

\subsection{Overloading}

Gli overloading servono a rendere più precise le firme delle funzioni.

\begin{example}
Vediamo un esempio pratico.

\begin{itemize}
  \item la funzione \texttt{f} deve restituire un numero se l'input è una stringa
  \item la funzione \texttt{f} deve restituire una stringa se l'input è un numero
\end{itemize}

Usare un'unione non è soddisfacente

\begin{code}
declare function f(x: string | number): number | string

// x1: string | number
const x1 = f("foo")
// x2: string | number
const x2 = f(1)
\end{code}

Definendo due overloading possiamo rendere preciso il tipo della funzione

\begin{code}
declare function g(x: number): string
declare function g(x: string): number
declare function g(
  x: string | number
): number | string

// x3: number
const x3 = g("foo")
// x4: string
const x4 = g(1)
\end{code}

La terza firma di \texttt{g} serve a guidare l'implementazione e \textbf{non comparirà nel definition file}
generato da TypeScript se \texttt{declaration = true} nel

\texttt{tsconfig.json}.

Gli overloading possono essere definiti anche per i metodi di una classe.

\begin{code}
class G {
  g(x: number): string
  g(x: string): number
  g(x: string | number): number | string {
    ...
  }
}
\end{code}

\begin{exercise}
Tipizzare la funzione \texttt{compose}
\end{exercise}

\end{example}

\subsection{Polimorfismo}

\begin{quote}
Parametric polymorphism refers to when the type of a value contains one or more (unconstrained) type variables,
so that the value may adopt any type that results from substituting those variables with concrete types.
\end{quote}

Una funzione viene detta \emph{polimorfica} se può gestire diversi tipi parametrizzati da uno o più \emph{type parameter},
\emph{monomorfica} altrimenti.

\begin{code}
// una funzione monomorfica
declare function head(xs: Array<number>): number | undefined

// una funzione polimorfica
declare function head<A>(xs: Array<A>): A | undefined
\end{code}

Le funzioni polimorfiche favoriscono una implementazione corretta e fanno emergere le assunzioni nascoste

\begin{code}
// compila
const head = (xs: Array<number>): number | undefined => {
  return 1
}

// non compila
const head = <A>(xs: Array<A>): A | undefined => {
  return 1
}
\end{code}

Esempio notevole è la funzione identità che ammette una sola implementazione possibile

\begin{code}
const identity = <A>(a: A): A => a
\end{code}

\begin{boxed}
Quando possibile, cercate di definire funzioni polimorfiche
\end{boxed}

\begin{exercise}
Date le firme delle seguenti funzioni, cosa possiamo dire del loro comportamento?

\begin{code}
declare function f(xs: Array<number>): Array<number>
declare function g<A>(xs: Array<A>): Array<A>
\end{code}
\end{exercise}

\subsection{Custom type guards}

Le custom type guard servono a \emph{raffinare i tipi}. Un raffinemento di un tipo \texttt{A} è un sottoinsieme \texttt{B} di \texttt{A}
tale che per ogni elemento vale un \emph{predicato}.

\begin{definition}
Un \emph{predicato} (sul tipo \texttt{A}) è una funzione con la seguente firma

\begin{code}
type Predicate<A> = (a: A) => boolean
\end{code}
\end{definition}

\begin{example}
In TypeScript la sintassi per definire un predicato non è sufficiente per raffinare un tipo

\begin{code}
const isString = (x: unknown): boolean => {
  return typeof x === "string"
}

const f = (x: string | number): number => {
  if (isString(x)) {
    // qui x non è raffinato
    return x.length // error
  } else {
    return x // error
  }
}
\end{code}
\end{example}

Invece viene utilizzata questa sintassi (che definisce una custom type guard)

\begin{code}
type Refinement<A, B extends A> = (a: A) => a is B
\end{code}

\begin{observation}
Notate che \texttt{B} \textbf{deve essere assegnabile} ad \texttt{A}.
O in altre parole \texttt{B} deve essere un \textbf{sottotipo} di \texttt{A}.
\end{observation}

\begin{boxed}
La keyword \texttt{extends} può essere usata per \textbf{mettere in relazione} due type parameter
\end{boxed}

In particolare \texttt{extends} viene spesso usata per definire dei vincoli su di un type parameter
che siano basati su un altro type parameter.

\begin{example}
Una semplice custom type guard: \texttt{isString}

\begin{code}
export const isString = (x: unknown): x is string => {
  return typeof x === "string"
}

const f = (x: string | number): number => {
  if (isString(x)) {
    // qui x è di tipo string
    return x.length
  } else {
    // qui x è di tipo number
    return x
  }
}
\end{code}
\end{example}

\begin{example}
Riprendiamo l'esempio del capitolo precedentemente

\begin{code}
const payload = `{"bar":"foo"}`
const x = parse(payload)

/*
if (typeof x === 'object') {
  // x ha tipo object | null
  if (x !== null) {
    // x ha tipo object
    const bar = (x as { [key: string]: unknown }).bar
    if (typeof bar === 'string') {
      // bar ha tipo string
      console.log(bar.trim())
    }
  }
}
*/

const isObject = (x: unknown): x is object =>
  typeof x === 'object' && x !== null

const isDictionary = (
  x: unknown
): x is { [key: string]: unknown } => isObject(x)

const isString = (x: unknown): x is string =>
  typeof x === 'string'

if (isDictionary(x)) {
  if (isString(x.bar)) {
    console.log(x.bar.trim())
  }
}
\end{code}
\end{example}

\begin{example}
Alcune custom type guard sono predefinite, un esempio notevole è \texttt{Array.isArray}

\begin{code}
const payload = `{"bar":[1,2,3]}`
const x = parse(payload)

if (Array.isArray(x)) {
  // x ha tipo Array<any>
  console.log(x.keys)
}
\end{code}
\end{example}

Notate però che \texttt{Array.isArray} raffina a \texttt{Array<any>}.

\begin{exercise}
Definire una versione di \texttt{Array.isArray} più type-safe
\end{exercise}

\begin{exercise}
Definire una custom type guard che raffina un valore qualsiasi in un \texttt{Array<number>}
\end{exercise}

\begin{exercise}
È possibile generalizzare la soluzione precedente?
\end{exercise}

\subsection{Lifting di un valore: l'operatore \texttt{typeof}}

I valori e i tipi vivono in mondi separati, però è possibile passare dal mondo dei valori a quello dei tipo
sfruttando l'operatore \texttt{typeof}.

\begin{observation}
Attenzione, in questo caso non stiamo parlando dell'omonimo operatore \texttt{typeof} di JavaScript, che lavora value-level, ma
dell'operatore \texttt{typeof} di TypeScript, che lavora type-level.
\end{observation}

\begin{example}
Ricavare il tipo di un oggetto

\begin{code}
const x = {
  foo: "foo",
  baz: 1
}

// value-level
const X = typeof x
// "object"

// type-level
type X = typeof x
/*
type X = {
  foo: string;
  baz: number;
}
*/
\end{code}
\end{example}

\subsection{Immutabilità: il modificatore \texttt{readonly}}

Il modificatore \texttt{readonly} rende immutabili i campi di un oggetto

\begin{example}
Rendere immutabile i campi di una interfaccia

\begin{code}
interface Person {
  readonly name: string
  readonly age: number
}

declare const person: Person

person.age = 42 // Cannot assign to 'age' because
// it is a constant or a read-only property
\end{code}
\end{example}

È possibile rendere immutabile anche una \emph{index signature}

\begin{code}
interface ImmutableDictionary {
  readonly [key: string]: number
}

declare const dict: ImmutableDictionary

dict["foo"] = 1 // Index signature in type
// 'ImmutableDictionary' only permits reading
\end{code}

Per rendere immutabile un tipo già definito è possibile usare il tipo predefinito \texttt{Readonly}
\footnote{Per l'implementazione di \texttt{Readonly} si veda la sezione Mapped types}

\begin{code}
interface Point {
  x: number
  y: number
}

type ImmutablePoint = Readonly<Point>
/*
type ImmutablePoint = {
    readonly x: number;
    readonly y: number;
}
*/
\end{code}

Per i field delle classi è possibile esprimere il modificatore \texttt{readonly} direttamente nel costruttore

\begin{code}
class Point2D {
  constructor(readonly x: number, readonly y: number) {}
}
\end{code}

\begin{example}
È anche possibile rendere immutabile un array con il tipo predefinito
\texttt{ReadonlyArray}.

\begin{code}
const x: ReadonlyArray<number> = [1, 2, 3]
x.push(4) // error: Property 'push' does
// not exist on type 'ReadonlyArray<number>'
\end{code}
\end{example}

Ci sono interfacce analoghe per \texttt{Map} e \texttt{Set}, rispettivamente \texttt{ReadonlyMap} e \texttt{ReadonlySet}.

\begin{exercise}
Rendere immutabile la seguente interfaccia

\begin{code}
interface Person {
  name: {
    first: string
    last: string
  }
  interests: Array<string>
}
\end{code}
\end{exercise}

\subsection{Index types}

\subsubsection{Index type query operator: \texttt{keyof}}

Così come è possibile, dato un oggetto, ricavare \textbf{il valore} delle chiavi tramite la funzione \texttt{Object.keys}

\begin{code}
const point = { x: 1, y: 2 }
const pointKeys = Object.keys(point)
// [ "x", "y" ]
\end{code}

così è possibile ricavare \textbf{il tipo} delle chiavi di un oggetto (come unione) usando l'operatore \texttt{keyof}.

\begin{example}
Estrarre il tipo delle chiavi di una interfaccia

\begin{code}
interface Point {
  x: number
  y: number
}

type PointKeys = keyof Point
/*
type PointKeys = "x" | "y"
*/
\end{code}

\texttt{keyof} può operare anche sugli array

\begin{code}
type ArrayKeys = keyof Array<number>
/*
type ArrayKeys = number | "length" | "toString" |
"toLocaleString" | "push" | "pop" | "concat" | "join" |
"reverse" | "shift" | "slice" | "sort" | "splice" |
"unshift" | "indexOf" | "lastIndexOf" | "every" | "some" |
"forEach" | "map" | "filter" | "reduce" | "reduceRight" |
"entries" | "keys" | "values" | "find" | "findIndex" |
"fill" | "copyWithin"
*/
\end{code}

e le tuple

\begin{code}
type TupleKeys = keyof [string, number]
/*
type TupleKeys = number | "0" | "1" | "length" | "toString" |
"toLocaleString" | "push" | "pop" | "concat" | "join" |
"reverse" | "shift" | "slice" | "sort" | "splice" |
"unshift" | "indexOf" | "lastIndexOf" | "every" |
"some" | "forEach" | "map" | "filter" | "reduce" |
"reduceRight" | "entries" | "keys" | "values" |
"find" | "findIndex" | "fill" | "copyWithin"
*/
\end{code}
\end{example}

\begin{exercise}
Rendere type safe la seguente funzione \texttt{translate}

\begin{code}
const translations = {
  when: "Quando",
  where: "Dove"
}

export declare function translate(key: string): string
\end{code}
\end{exercise}

\subsubsection{Indexed access operator \texttt{[]}}

Così come è possibile, dato un oggetto, ricavare il valore di una sua proprietà usando l'accesso per indice

\begin{code}
const person = { name: "Giulio", age: 44 }
const name = person["name"]
\end{code}

così l'operatore \texttt{T[K]} permette di estrarre il tipo del campo \texttt{K} dal tipo \texttt{T}

\begin{example}
Estrarre il tipo di una chiave di una interfaccia

\begin{code}
interface Person {
  name: string
  age: number
}

type Name = Person["name"]
/*
type Name = string
*/

type Age = Person["age"]
/*
type Age = number
*/

type Unknown = Person["foo"] // error
\end{code}
\end{example}

\begin{exercise}
Ricavare il tipo del campo \texttt{baz} della seguente interfaccia

\begin{code}
interface Foo {
  foo: {
    bar: {
      baz: number
      quux: string
    }
  }
}
\end{code}
\end{exercise}

\begin{exercise}
Ricavare il tipo delle chiavi del campo \texttt{bar} dell'interfaccia \texttt{Foo} definita nel precedente esercizio.
\end{exercise}

\begin{exercise}
Tipizzare la seguente funzione \texttt{get} in modo che gli argomenti e il tipo di ritorno siano i più precisi possibile

\begin{code}
declare function get(key: string, obj: unknown): unknown
\end{code}
\end{exercise}

\begin{exercise}
Aggiungere degli alias a delle proprietà di una classe.

Un \emph{isomorfismo} $f: S \rightarrow A$ è una funzione invertibile, ovvero esiste una funzione $f^{-1}: A \rightarrow S$ tale che

$$
f \circ f^{-1} = f^{-1} \circ f = identity
$$

\[
\xymatrixrowsep{3cm}
\xymatrixcolsep{3cm}
\xymatrix{
  S \ar@/_0.5cm/[r]_{\texttt{get}} & A \ar@/_0.5cm/[l]_{\texttt{reverseGet}}
}
\]

\begin{code}
/**
 * Rappresenta un isomorfismo tra gli insiemi S e A
 */
class Iso<S, A> {
  constructor(
    readonly get: (s: S) => A,
    readonly reverseGet: (a: A) => S
  ) {}
}
\end{code}

\begin{itemize}
  \item aggiungere gli alias \texttt{unwrap} e \texttt{to} per \texttt{get}
  \item aggiungere gli alias \texttt{wrap} e \texttt{from} per \texttt{reverseGet}
\end{itemize}

\end{exercise}

\begin{exercise}
Estrarre il tipo della prima e della seconda componente della seguente tupla

\begin{code}
type Tuple = [number, string, boolean]

// estrarre la prima componente
type Num = ?
// estrarre la seconda componente
type Str = ?

\end{code}
\end{exercise}

\begin{observation}
Come è possibile estrarre l'\textbf{unione} dei tipi di una tupla? Accedendo con l'indice generico \texttt{number}

\begin{code}
type X = [string, number]

type ValuesOfX = X[number]
// type ValuesOfX = string | number
\end{code}
\end{observation}

\begin{exercise}
Tipizzare la seguente funzione \texttt{set} in modo che gli argomenti e il tipo di ritorno siano i più precisi possibile

\begin{code}
declare function set(
  k: string,
  v: unknown,
  o: unknown
): unknown
\end{code}
\end{exercise}

\begin{observation}
Si noti che \texttt{Object.keys} è tipizzato così

\begin{code}
Object.keys: (o: {}) => string[]
\end{code}
\end{observation}

\begin{exercise}
Perchè? Quale alternativa potremmo definire?
\end{exercise}

\subsection{Mapped types}

TypeScript fornisce un modo per creare nuovi tipi basati su tipi già definiti, i \emph{mapped types}.
La formula generale di un mapped type è la seguente

$$
\{ [\texttt{K in U}]: f(\texttt{K}) \}
$$

ove

\begin{itemize}
  \item \texttt{K} è una variabile
  \item \texttt{U} è una unione
  \item $f$ è una funzione di \texttt{K}
\end{itemize}

\begin{example}
Creare un \emph{option object}

\begin{code}
type Flag = "option1" | "option2" | "option3"

type Options = { [K in Flag]: boolean }
/*
type Options = {
    option1: boolean;
    option2: boolean;
    option3: boolean;
}
*/
\end{code}
\end{example}

Come soluzione è possibile anche usare il tipo predefinito \texttt{Record} (per la sua definizione vedi oltre)

\begin{code}
type Options = Record<Flag, boolean>
\end{code}

\begin{exercise}
Derivare un record di predicati dalla seguente interfaccia

\begin{code}
interface X {
  a: string
  b: number
  c: boolean
}
/*
Risultato atteso:
{
  a: (x: string) => boolean
  b: (x: number) => boolean
  c: (x: boolean) => boolean
}
*/
\end{code}
\end{exercise}

\begin{exercise}
Dato lo string literal type

\begin{code}
type Key = "foo"
\end{code}

derivare il tipo

\begin{code}
type O = {
  foo: number
}
\end{code}
\end{exercise}

Vediamo ora qualche tipo predefinito definito grazie a questa feature

\begin{example}
\texttt{Partial<T>}

\begin{code}
/**
 * Make all properties in T optional
 */
type Partial<T> = { [P in keyof T]?: T[P] }
\end{code}
\end{example}

\begin{observation}
Il modificatore \texttt{?} rende opzionali tutti i campi.
\end{observation}

\begin{example}
\texttt{Required<T>}

\begin{code}
/**
 * Make all properties in T required
 */
type Required<T> = { [P in keyof T]-?: T[P] }
\end{code}
\end{example}

\begin{observation}
Il modificatore \texttt{-?} rende obbligatori tutti i campi.
\end{observation}

\begin{example}
\texttt{Readonly<T>}

\begin{code}
/**
* Make all properties in T readonly
*/
type Readonly<T> = { readonly [P in keyof T]: T[P] }
\end{code}
\end{example}

\begin{observation}
Il modificatore \texttt{readonly} rende tutti i campi in sola lettura.
\end{observation}

\begin{example}
\texttt{Pick<T, K>}

\begin{code}
/**
* From T pick a set of properties K
*/
type Pick<T, K extends keyof T> = { [P in K]: T[P] }
\end{code}
\end{example}

\begin{example}
\texttt{Record<K, T>}

\begin{code}
/**
 * Construct a type with a set of properties K of type T
 */
type Record<K extends keyof any, T> = { [P in K]: T }
\end{code}
\end{example}

\begin{exercise}
Rendere type safe la funzione \texttt{pick}

\begin{code}
declare function pick(ks: Array<string>, o: never): never
\end{code}
\end{exercise}

\subsection{Subtyping e type parameter}

Come abbiamo gà visto la keyword \texttt{extends} viene usata per estendere una classe

\begin{code}
class Cat extends Animal {}
\end{code}

ma è spesso usata anche esprimere una relazioni tra type parameter.

Vediamo un altro esempio in cui questa feature risulta utile

\begin{example}
Definire un getter generico

\begin{code}
interface Person {
  name: string
  age: number
}

const getName = (p: Person): string => p.name
\end{code}

La funzione \texttt{getName} è fin troppo restrittiva, accetta in input un tipo \texttt{Person} ma, data l'implementazione,
potrebbe lavorare su qualsiasi record che contiene un campo \texttt{name} di tipo \texttt{string}

\begin{code}
const getName = <T extends { name: string }>(x: T): string =>
  x.name
\end{code}
\end{example}

\begin{exercise}
Generalizzare \texttt{getName} in modo che lavori con qualsiasi tipo che abbia una proprietà \texttt{name},
indipendentemente dal suo tipo
\end{exercise}

\begin{exercise}
\texttt{getName} è una funzione che lavora su un campo specifico (\texttt{name}), definire
una funzione \texttt{getter} che, dato il nome di un campo, restituisce il getter corrispondente

\begin{code}
const getName = getter("name")
\end{code}
\end{exercise}

\subsection{Module augmentation}

\begin{example}
Riaprire una classe modificandone il \texttt{prototype}

\begin{code}
// foo.ts
class Foo {
  doSomething(): string {
    return "foo"
  }
}

// augment.ts
import { Foo } from "./foo"

declare module "./Foo" {
  interface Foo {
    doSomethingElse(): number
  }
}

Foo.prototype.doSomethingElse = function() {
  return this.doSomething().length
}

new Foo().doSomethingElse() // ok
\end{code}
\end{example}

Un caso comune di utilizzo di questa feature è quello di "correggere" i typings di una libreria esterna.

\subsection{Conditional types}

I \emph{conditional types} hanno la seguente sintassi

\begin{code}
T extends U ? X : Y
\end{code}

Questa scrittura significa

\begin{quote}
se \texttt{T} è assegnabile a \texttt{U} allora il tipo risultante è \texttt{X}, altrimenti è \texttt{Y}
\end{quote}

\begin{example}
Tipizzare l'operatore \texttt{typeof}

\begin{code}
type TypeName<T> =
    T extends string ? "string" :
    T extends number ? "number" :
    T extends boolean ? "boolean" :
    T extends undefined ? "undefined" :
    T extends Function ? "function" :
    "object";

type T0 = TypeName<string>;  // "string"
type T1 = TypeName<'a'>;  // "string"
type T2 = TypeName<true>;  // "boolean"
type T3 = TypeName<() => void>;  // "function"
type T4 = TypeName<string[]>;  // "object"
\end{code}
\end{example}

I conditional types \emph{distribuiscono} le unioni, ovvero se per esempio

\begin{code}
T extends U ? X : Y
\end{code}

è istanziato con \texttt{T = A | B | C }, allora il conditional type è risolto in

\begin{code}
  (A extends U ? X : Y)
| (B extends U ? X : Y)
| (C extends U ? X : Y)
\end{code}

Vediamo qualche tipo built-in che sfrutta i conditional types

\begin{example}
\texttt{Exclude}

\begin{code}
/**
 * Exclude from T those types that are assignable to U
 */
type Exclude<T, U> = T extends U ? never : T;
\end{code}
\end{example}

Vediamo come funziona con un esempio concreto

\begin{code}
// voglio una copia di `Person` tranne il campo `age`
export interface Person {
  firstName: string
  lastName: string
  age: number
}

type NotAge = Exclude<keyof Person, 'age'>

type Explanation =
  | ("firstName" extends "age" ? never : "firstName")
  | ("lastName" extends "age" ? never : "lastName")
  | ("age" extends "age" ? never : "age")

type Result = Pick<Person, NotAge>
/* same as
type Result = {
    firstName: string;
    lastName: string;
}
*/
\end{code}

\begin{example}
\texttt{Extract}

\begin{code}
/**
 * Extract from T those types that are assignable to U
 */
type Extract<T, U> = T extends U ? T : never;
\end{code}
\end{example}

\begin{example}
\texttt{NonNullable}

\begin{code}
/**
 * Exclude null and undefined from T
 */
type NonNullable<T> = T extends null | undefined ? never : T;
\end{code}
\end{example}

Nell clausola \texttt{extends} di un conditional type è possibile utilizzare la keyword \texttt{infer} che introduce
una type variable da far inferire al type checker. Queste type variable possono essere poi utilizzate nel ramo positivo
del conditional type.

\begin{example}
\texttt{ReturnType}

\begin{code}
/**
 * Obtain the return type of a function type
 */
type ReturnType<T extends (...args: any[]) => any> =
  T extends (...args: any[]) => infer R ? R : any;
\end{code}
\end{example}

\begin{example}
\texttt{Equals} e \texttt{AssertEquals}

\begin{code}
type Equals<A, B> = [A] extends [B] ?
  ([B] extends [A] ? "T" : "F") : "F"

type AssertEquals<A, B, Bool extends Equals<A, B>> = [A, Bool]
\end{code}
\end{example}

Per ulteriori esempi, si veda:

https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html

\begin{exercise}
Ricavare le chiavi di \texttt{X} che hanno valori di tipo \texttt{string}

\begin{code}
interface X {
  a: string
  b: number
  c: string
}
\end{code}
\end{exercise}

\begin{exercise}
Tipizzare la funzione \texttt{remove}
\end{exercise}

\begin{exercise}
Manipolazione di unioni taggate: estrarre o escludere dei membri
\end{exercise}

\begin{exercise}
Tipizzare la funzione \texttt{omit}
\end{exercise}

\subsection{Mapped tuples}

Fino alla versione \texttt{3.0.x} i rest parameter erano tipizzabili esclusivamente con \texttt{Array}

\begin{example}
La funzione \texttt{Math.min}

\begin{code}
/**
 * Returns the smaller of a set of supplied numeric
 * expressions.
 */
min(...values: Array<number>): number
\end{code}
\end{example}

Nel caso di \texttt{min} tipizzare con \texttt{Array} è corretto dato che i parametri sono omogenei (tutti di tipo \texttt{number}),
ma come è possibile gestire parametri con tipi diversi?

\begin{example}
La funzione di utility \texttt{tuple}. Per capire perchè dovremmo aver bisogno di una tale funzione di utility si consideri il seguente

\begin{code}
// x: (string | number)[]
const x = [1, "foo"]
\end{code}

Qui vorremmo che TypeScript inferisse \texttt{x: [number, string]} ma di default il type checker inferisce un valore di tipo \texttt{Array}.

Per ovviare a questo problema possiamo definire una funzione di utility \texttt{tuple}

\begin{code}
function tuple<A, B>(a: A, b: B): [A, B] {
  return [a, b]
}

// x: [number, string]
const x = tuple(1, "foo")
\end{code}

E se volessimo una tupla con 3 componenti? Possiamo definire degli overloading ma è scomodo e il numero di overloading è arbitrario

\begin{code}
function tuple<A, B, C>(a: A, b: B, c: C): [A, B, C]
function tuple<A, B>(a: A, b: B): [A, B]
function tuple(...t: Array<any>): Array<any> {
  return t
}

// y: [number, string, boolean]
const y = tuple(1, "foo", true)
\end{code}

Oppure possiamo gestire un numero variabile di argomenti sfruttando le nuove capacità della versione \texttt{3.1.x}

\begin{code}
function tuple<T extends Array<any>>(...t: T): T {
  return t
}

// x: [number, string]
const x = tuple(1, "foo")
// y: [number, string, boolean]
const y = tuple(1, "foo", true)
\end{code}

\end{example}

È possibile mappare le tuple così come abbiamo visto fare con i mapped type

\begin{code}
declare function toPairs<T extends Array<any>>(
  ...t: T
): { [K in keyof T]: [K, T[K]] }

// const x: [["0", number], ["1", string], ["2", boolean]]
const x = toPairs(1, "s", true)
\end{code}

\begin{exercise}
Tipizzare la seguente funzione \texttt{all} in modo che preservi le tuple

\begin{code}
function all(ps: Array<Promise<unknown>>): Promise<unknown>
\end{code}
\end{exercise}

\newpage
\section{Definition file}

Un \emph{definition file} contiene solo dichiarazioni di tipi e servono a descrivere le API pubbliche di una package.

Tipicamente il nome di un definition file termina con \texttt{.d.ts}.

\subsection{Il flag \texttt{declaration}}

È possibile far generare a TypeScript i definition file dei moduli scritti in TypeScript impostando nel \texttt{tsconfig.json}
il flag \texttt{declaration: true}.

\subsection{Un problema serio: le API JavaScript}

Le API delle librerie JavaScript sono pensate per essere ergonomiche e consumate da JavaScript,
aggiungere un definition file a posteriori è spesso problematico.

In più spesso i definition file ufficiali non sono del tutto soddisfacenti.

Possibili soluzioni

\begin{itemize}
\item cambiare libreria
\item definire un custom definition file
\item definire una funzione wrapper con una tipizzazione sana
\item castare ad una tipizzazione sana
\item module augmentation / declaration merging
\end{itemize}

\begin{example}
Correggere lodash (49.000.000 di download / mese)

\begin{code}
// lodash@4.17.11
// @types/lodash@4.14.118
import * as _ from "lodash"

const f = (a: number, b: string): number =>
  a + b.trim().length

/*

  La funzione `flip` è definita con questa tipizzazione

  flip<T extends (...args: any[]) => any>(func: T): T;

*/
const g = _.flip(f)

g(1, "a") // esplode a runtime: b.trim is not a function
\end{code}

Una possibile soluzione: module augmentation / declaration merging

\begin{code}
declare module "lodash" {
  interface LoDashStatic {
    flip<A, B, C>(f: (a: A, b: B) => C): (b: B, a: A) => C
    flip<A, B>(f: (a: A) => B): (a: A) => B
    flip<A>(f: () => A): () => A
  }
}
\end{code}

\end{example}

\begin{exercise}
Correggere la funzione \texttt{\_.get}
\end{exercise}

\newpage
\section{TDD (Type Driven Development)}

\begin{quote}
"Type driven development" is a technique used to split a problem into a set of smaller problems,
letting the type checker suggest the concrete implementation, or at least helping us getting there.
\end{quote}

\begin{example}
Reimplementare \texttt{Promise.all}.

\begin{code}
declare function sequence<T>(
  promises: Array<Promise<T>>
): Promise<Array<T>>
\end{code}

\end{example}

\begin{boxed}
live coding...
\end{boxed}

\newpage
\section{ADT (Algebraic Data Types)}

https://github.com/gcanti/talks/blob/master/adt/adt.md

\begin{exercise}
Modellare il tipo \texttt{JSON}. Si può considerare un ADT?
\end{exercise}

\begin{exercise}
Modellare un albero binario
\end{exercise}

\begin{exercise}
Modellare una struttura dati (chiamiamola \texttt{These}) che rappresenta alternativamente
\begin{itemize}
  \item un successo di tipo \texttt{A}
  \item un errore bloccante di tipo \texttt{L}
  \item un successo di tipo \texttt{A} e un errore non bloccante di tipo \texttt{L}\footnote{
Tratto da https://package.elm-lang.org/packages/joneshf/elm-these/1.2.0/

There are a few ways to interpret the both case:

\begin{itemize}
  \item You can think of a computation that has a non-fatal error.
  \item You can think of a computation that went as far as it could before erroring.
  \item You can think of a computation that keeps track of errors as it completes.
\end{itemize}
  }
\end{itemize}
\end{exercise}

\begin{exercise}
Definire una funzione \texttt{match} che simuli il pattern matching per \texttt{These}
\end{exercise}

\begin{exercise}
Tennis Kata: modellare il punteggio di un game
\end{exercise}

\newpage
\section{Error handling funzionale}

Consideriamo la funzione

\begin{code}
const inverse = (x: number): number => 1 / x
\end{code}

Come abbiamo visto nell'introduzione tale funzione si dice \emph{parziale} perchè non è definita per tutti i valori del dominio
(in particolare non è definita per $x = 0$).

Come possiamo gestire questa situazione?

Una soluzione potrebbe essere lanciare un'eccezione

\begin{code}
const inverse = (x: number): number => {
  if (x !== 0) return 1 / x
  throw new Error('cannot divide by zero')
}
\end{code}

ma così la funzione non sarebbe più da considerarsi pura
\footnote{Le eccezioni sono considerate un side effect inaccettabile perchè modificano la normale esecuzione del codice
e violano la \textbf{trasparenza referenziale}

\begin{quote}
An expression is said to be \emph{referentially transparent} if it can be replaced with its corresponding value without changing the program's behavior
\end{quote}
}.

Un'altra possibile soluzione è restituire \texttt{null} (oppure un altro valore \emph{sentinella})

\begin{code}
const inverse = (x: number): number | null => {
  if (x !== 0) return 1 / x
  return null
}
\end{code}

Sorge però un nuovo problema quando si cerca di comporre la funzione \texttt{inverse} così modificata con un'altra funzione

\begin{code}
const double = (n: number): number => n * 2

// calcola l'inverso e poi moltiplica per 2
const doubleInverse = (x: number): number => double(inverse(x))
\end{code}

L'implementazione di \texttt{doubleInverse} non è corretta, cosa succede se \texttt{inverse(x)} restituisce \texttt{null}?
Occorre tenerne conto

\begin{code}
const doubleInverse = (x: number): number | null => {
  const y = inverse(x)
  if (y === null) return null
  return double(y)
}
\end{code}

Appare evidente come l'obbligo di gestione del valore speciale \texttt{null} si propaghi in modo contagioso
a tutti gli utilizzatori di \texttt{inverse}.

Questo approccio ha alcuni svantaggi

\begin{itemize}
  \item molto boilerplate
  \item le funzioni non compongono facilmente
\end{itemize}

\subsection{Il tipo \texttt{Option}}

La soluzione funzionale ai problemi illustrati precedentemente è l'utilizzo del tipo \texttt{Option},
eccone la definizione

\begin{code}
// sum type
type Option<A> = None<A> | Some<A>

class None<A> {
  readonly _tag: "None" = "None"
  map<B>(f: (a: A) => B): Option<B> {
    return none
  }
  chain<B>(f: (a: A) => Option<B>): Option<B> {
    return none
  }
}

class Some<A> {
  readonly _tag: "Some" = "Some"
  constructor(readonly value: A) {}
  map<B>(f: (a: A) => B): Option<B> {
    return new Some(f(this.value))
  }
  chain<B>(f: (a: A) => Option<B>): Option<B> {
    return f(this.value)
  }
}

const none: Option<never> = new None()

const some = <A>(a: A): Option<A> => new Some(a)
\end{code}

Ridefiniamo \texttt{inverse} sfruttando \texttt{Option}

\begin{code}
const inverse = (x: number): Option<number> =>
  x === 0 ? none : some(1 / x)
\end{code}

Possiamo interpretare questa modifica in termini di successo e fallimento: se viene restituita una istanza di \texttt{Some}
la computazione di \texttt{inverse} ha avuto successo, se viene restituita una istanza di \texttt{None} essa è fallita.

\begin{boxed}
Il tipo \texttt{Option} codifica l'\emph{effetto} di una computazione che può fallire
\end{boxed}

Ora è possibile definire \texttt{doubleInverse} senza boilerplate

\begin{code}
const doubleInverse = (x: number): Option<number> =>
  inverse(x).map(double)

doubleInverse(2) // Some(1)
doubleInverse(0) // None
\end{code}

Inoltre è facile concatenare altre operazioni

\begin{code}
const inc = (x: number): number => x + 1

inverse(0)
  .map(double)
  .map(inc) // None
inverse(4)
  .map(double)
  .map(inc) // Some(1.5)
\end{code}

\begin{boxed}
\texttt{Option} mi permette di concentrarmi solo sul \emph{path di successo} in una serie di computazioni che possono fallire
\end{boxed}

Inoltre è possibile concatenare varie operazioni che possono fallire tramite il metodo \texttt{chain}

\begin{code}
const head = <A>(as: Array<A>): Option<A> => {
  return as.length > 0 ? some(as[0]) : none
}

head([]).chain(inverse) // None
head([1, 2, 3]).chain(inverse) // Some(0.5)
head([0, 1, 2]).chain(inverse) // None
\end{code}

\begin{exercise}
Definire la funzione \texttt{index} che, dato un array e un indice, restituisce l'elemento a quell'indice (se esiste)
\end{exercise}

\begin{exercise}
Definire la funzione \texttt{updateAt} che, dato un array, un indice e una funzione, restituisce un nuovo array
con la funzione applicata all'\texttt{i}-esimo suo elemento
\end{exercise}

\subsection{Branching tramite la funzione \texttt{fold}}

Prima o poi dovrò affrontare il problema di stabilire cosa fare sia nel caso di successo che di fallimento.
La funzione \texttt{fold} permette di gestire i due casi

\begin{code}
class None<A> {
  ...
  fold<R>(whenNone: R, whenSome: (a: A) => R): R {
    return whenNone
  }
  // variante "lazy"
  foldL<R>(whenNone: () => R, whenSome: (a: A) => R): R {
    return whenNone()
  }
}

class Some<A> {
  ...
  fold<R>(whenNone: R, whenSome: (a: A) => R): R {
    return whenSome(this.value)
  }
  foldL<R>(whenNone: () => R, whenSome: (a: A) => R): R {
    return whenSome(this.value)
  }
}
\end{code}

Vediamo un esempio di utilizzo

\begin{code}
const whenNone = (): string => "cannot divide by zero"
const whenSome = (x: number): string => "the result is" + x

inverse(2).foldL(whenNone, whenSome)
// "the result is 0.5"
inverse(0).foldL(whenNone, whenSome)
// "cannot divide by zero"
\end{code}

Si noti come il branching è racchiuso nella definizione di \texttt{Option} e non necessita di alcun \texttt{if}
e che l'utilizzo necessita solo di funzioni.

Inoltre le funzioni \texttt{f} e \texttt{g} sono generiche e riutilizzabili.

\subsection{Interoperabilità}

Per questioni di interoperabilità con codice che non usa \texttt{Option} possiamo definire alcune funzioni di utility

\begin{code}
const fromNullable = <A>(
  a: A | null | undefined
): Option<A> => a == null ? none : some(a)

const toNullable = <A>(fa: Option<A>): A | null =>
  fa.fold(null, identity)

const toUndefined = <A>(fa: Option<A>): A | undefined =>
  fa.fold(undefined, identity)
\end{code}

\subsection{Il tipo \texttt{Either}}

Il tipo \texttt{Option} è utile quando c'è un solo modo evidente per il quale una computazione può fallire,
oppure ce ne sono diversi ma non interessa distinguerli.

Se invece esistono molteplici ragioni di fallimento ed interessa comunicare al chiamante quale si sia verificata,
oppure se si vuole definire un errore personalizzato, è possibile impiegare il tipo \texttt{Either}. Eccone la definizione

\begin{code}
type Either<L, A> = Left<L, A> | Right<L, A>

class Left<L, A> {
  readonly _tag: "Left" = "Left"
  constructor(readonly value: L) {}
  map<B>(f: (a: A) => B): Either<L, B> {
    return this as any
  }
  chain<B>(f: (a: A) => Either<L, B>): Either<L, B> {
    return this as any
  }
}

class Right<L, A> {
  readonly _tag: "Right" = "Right"
  constructor(readonly value: A) {}
  map<B>(f: (a: A) => B): Either<L, B> {
    return new Right(f(this.value))
  }
  chain<B>(f: (a: A) => Either<L, B>): Either<L, B> {
    return f(this.value)
  }
}

const left = <L, A>(l: L): Either<L, A> =>
  new Left(l)

const right = <L, A>(a: A): Either<L, A> =>
  new Right(a)
\end{code}

Per convenzione \texttt{Left} rappresenta il caso di fallimento mentre \texttt{Right} quello di successo.

Ridefiniamo la funzione \texttt{inverse} in funzione del tipo \texttt{Either}

\begin{code}
const inverse = (x: number): Either<string, number> =>
  x === 0 ? left("cannot divide by zero") : right(1 / x)
\end{code}

Ancora una volta è possibile definire \texttt{doubleInverse} senza boilerplate

\begin{code}
const doubleInverse = (x: number): Either<string, number> =>
  inverse(x).map(double)

doubleInverse(2) // Right(1)
doubleInverse(0) // Left('cannot divide by zero')
\end{code}

ed è facile comporre insieme altre operazioni

\begin{code}
inverse(0)
  .map(double)
  .map(inc) // Left('cannot divide by zero')
inverse(4)
  .map(double)
  .map(inc) // Right(1.5)
\end{code}

Anche per il tipo \texttt{Either} è possibile definire una funzione \texttt{fold}

\begin{code}
class Left<L, A> {
  ...
  fold<R>(
    whenLeft: (l: L) => R,
    whenRight: (a: A) => R
  ): R {
    return whenLeft(this.value)
  }
}

class Right<L, A> {
  ...
  fold<R>(
    whenLeft: (l: L) => R,
    whenRight: (a: A) => R
  ): R {
    return whenRight(this.value)
  }
}
\end{code}

\begin{exercise}
Tipizzare le callback nelle API di node.js

Un esempio tipico di una API in node.js è \texttt{readFile}

\begin{code}
declare function readFile(
  path: string,
  callback: (err: Error | undefined, data?: string) => void
): void
\end{code}

Il problema di questa tipizzazione è che può rappresentare anche situazioni che dovrebbero essere escluse, in particolare
quella in cui sia \texttt{err} che \texttt{data} sono presenti.

Una migliore tipizzazione può essere realizzata sfruttando il tipo \texttt{Either}

\begin{code}
declare function betterReadFile(
  path: string,
  callback: (result: Either<Error, string>) => void
): void
\end{code}
\end{exercise}

La tipizzazione standard delle \texttt{Promise} non prevede un tipo per gli errori.

Anche in questo caso una migliore tipizzazione può essere realizzata sfruttando il tipo \texttt{Either}.

\begin{exercise}
Definire un wrapper della seguente funzione \texttt{readFile} in modo che utiizzi \texttt{Either} nel tipo di ritorno

\begin{code}
declare function readFile(path: string): Promise<string>
\end{code}
\end{exercise}

\newpage
\section{Finite state machines}

\begin{quote}
In general, a finite-state machine can be described as an abstract machine with \textbf{a finite set of states},
being is in one state at a time. \textbf{Events trigger state transitions}; that is, the machine changes from being in one
state to being in another state. The machine defines a set of \textbf{legal transitions}, often expressed as \textbf{associations
from the current state and an event to another state}.
\footnote{https://wickstrom.tech/finite-state-machines/2017/11/10/finite-state-machines-part-1-modeling-with-haskell.html}
\end{quote}

Gli stati e gli eventi, chiamiamoli rispettivamente \texttt{S} e \texttt{E}, possono essere modellati con dei sum type.

Il modello di una finite state machine è allora

\begin{code}
type PureFSM<S, E> = (s: S, e: E) => S
\end{code}

Siccome però è probabile che per produrre il nuovo stato occorra eseguire dei side effect, un modello più realistico è il seguente

\begin{code}
type FSM<S, E> = (s: S, e: E) => Promise<S>
\end{code}

\begin{exercise}
Modellare la seguente macchina a stati finiti (shopping cart checkout) usando degli ADT sia per gli stati sia per gli eventi

\[
\xymatrixrowsep{3cm}
\xymatrixcolsep{3cm}
\xymatrix{
  NoItems \ar[r]^{\texttt{select}} & HasItems \ar@(ul,ur)^{\texttt{select}} \ar@/_0.5cm/[r]_{\texttt{checkout}} & NoCard \ar[d]_{\texttt{selectCard}} \ar@/_0.5cm/[l]_{\texttt{cancel}} \\
  OrderPlaced & CardConfirmed \ar[u]^{\texttt{cancel}} \ar[l]^{\texttt{placeOrder}} & CardSelected \ar[ul]^{\texttt{cancel}} \ar[l]^{\texttt{confirm}} \\
}
\]
\end{exercise}

\newpage
\section{Come migliorare la type inference delle funzioni polimorfiche}

Consideriamo la generica definizione di funzione

$$
\texttt{const f} = \underbrace{(a_1, \ldots, a_n)}_A \texttt{ => } \underbrace{(b_{n + 1}, \ldots, b_m)}_B \texttt{ => } \ldots \texttt{ => } \texttt{ \{ } \ldots \texttt{ \} }
$$

Chiamiamo $A$, $B$, \ldots col nome di \emph{gruppi di argomenti} della funzione \texttt{f}.

Quando la funzione definita è polimorfica, ogni gruppo di argomenti è sede di inferenza per TypeScript.

\begin{example}
La seguente funzione ha un solo gruppo di argomenti e TypeScript è in grado di inferire correttamente tutti i type parameter coinvolti

\begin{code}
const map = <A, B>(
  f: (a: A) => B,
  fa: Array<A>
): Array<B> => fa.map(f)

// map: <string, number>
map(s => s.length, ["foo"])
\end{code}

se consideriamo la versione curried di \texttt{map} le cose cambiano

\begin{code}
const mapCurried = <A, B>(f: (a: A) => B) => (
  fa: Array<A>
): Array<B> => fa.map(f)

// mapCurried: <{}, any>
mapCurried(s => s.length)(["foo"])
// error: Property 'length' does not exist on type '{}'
\end{code}

TypeScript non è in grado di inferire il type parameter \texttt{A} nel primo gruppo di argomenti e gli assegna il tipo \texttt{\{\}}.
Lo sviluppatore perciò deve correggere la situazione aggiungendo una type annotation alla callback

\begin{code}
// mapCurried: mapCurried: <string, number>(f:
// (a: string) => number) => (fa: string[]) => number[]
mapCurried((s: string) => s.length)(["foo"])
\end{code}

oppure specificando i type parameter

\begin{code}
mapCurried<string, number>(s => s.length)(["foo"])
\end{code}

È però possibile migliorare la type inference scambiando l'ordine dei gruppi di argomenti

\begin{code}
const mapCurriedFlipped = <A>(fa: Array<A>) => <B>(
  f: (a: A) => B
): Array<B> => fa.map(f)

// mapCurriedFlipped: <string>(fa: string[]) =>
// <B>(f: (a: string) => B) => B[]
mapCurriedFlipped(["foo"])(s => s.length)
\end{code}
\end{example}

\newpage
\section{Simulazione dei tipi nominali}

È possibile simulare i tipi nominali aggiungendo una proprietà privata fittizia (detta \emph{phantom property}) che non viene mai valorizzata
a runtime ma che viene comunque presa in considerazione dal type checker.

\begin{example}
Implementazione con le classi

\begin{code}
class USD {
  private readonly brand!: symbol
  constructor(readonly value: number) {}
}

class EUR {
  private readonly brand!: symbol
  constructor(readonly value: number) {}
}

declare function f(usd: USD): void

f(new USD(1))
f(new EUR(1))
/*
[ts]
Argument of type 'EUR' is not assignable to parameter
of type 'USD'. Types have separate declarations of a
private property 'brand'
*/
\end{code}
\end{example}

Si noti l'uso del \emph{definite property assignment assertion operator}.

\newpage
\section{Refinements e smart constructors}

Consideriamo la funzione \texttt{inverse}

\begin{code}
const inverse = (x: number): Option<number> =>
  x === 0 ? none : some(1 / x)
\end{code}

Un altro modo per ottenere lo stesso grado di type safety senza avere una funzione parziale è l'utilizzo degli \emph{smart constructors}.

In pratica si fa in modo che \texttt{Option} non compaia a valle, nel codominio di \texttt{inverse},
ma a monte, in fase di creazione dell'input \texttt{x}.

Supponiamo di volere rappresentare il tipo "numero diverso da zero", possiamo implementarlo con un wrapper nominale

\begin{code}
class NonZero {
  private readonly brand!: symbol
  constructor(readonly value: number) {}
}
\end{code}

Il problema è che non ho controllo sulla creazione

\begin{code}
const x = new NonZero(0) // oops!
\end{code}

Posso allora definire uno \emph{smart constructor}, ovvero una funzione che ha come codominio \texttt{Option<NonZero>} e che
effettua il controllo a runtime

\begin{code}
export const create = (n: number): Option<NonZero> =>
  n === 0 ? none : some(new NonZero(n))
\end{code}

Nella pratica uno smart constructor trasporta un controllo a runtime a livello dei tipi.

Si noti che \texttt{NonZero} non è esportato mentre dal modulo è esportata la sola funzione \texttt{create}, in questo
modo si mantiene il controllo totale sulla creazione di istanze di \texttt{NonZero} che non sempre valide.

Tuttavia ci può essere una complicazione se \texttt{declaration = true} nel \texttt{tsconfig.json}
(caso che può capitare se per esempio se si sta scrivendo una libreria). In questo caso
TypeScript costringe ad esportare anche il tipo \texttt{NonZero}, ma con esso \textbf{anche il costruttore}.

Si può rimediare con il seguente workaround

\begin{itemize}
\item rendere privato il costruttore di \texttt{NonZero}
\item spostare la definizione di \texttt{creare} come funzione statica di \texttt{NonZero}
\end{itemize}

\begin{code}
class NonZero {
  private readonly brand!: symbol
  static create(n: number): Option<NonZero> {
    return n === 0 ? none : some(new NonZero(n))
  }
  private constructor(readonly value: number) {}
}

// inverse adesso è totale!
const inverse = (x: NonZero): number => 1 / x.value
\end{code}

In questo modo si possono spingere i controlli a runtime là dove dovrebbe essere il loro posto naturale: ai confini del sistema,
dove vengono fatte tutte le validazioni dell'input.

\newpage
\section{Phantom types}

Un \emph{phantom type} è un tipo polimorfico i cui type parameter non appaiono tutti alla destra della sua definizione

\begin{code}
type Phantom<M> = { value: number }
\end{code}

Qui \texttt{Phantom} è un phantom type e \texttt{M} è un \emph{phantom type parameter},
dato che il parametro \texttt{M} non appare nella sua implementazione.

Dato che TypeScript ha un type system strutturale dobbiamo però scegliere una diversa implementazione.

\begin{exercise}
Perchè?
\end{exercise}

per esempio una classe con una phantom property

\begin{code}
class Phantom<M> {
  private readonly M!: M
  constructor(readonly value: number) {}
}
\end{code}

\subsection{Validating user input}

Say you have a

\begin{code}
declare function use(input: string): void
\end{code}

function (the return type doesn't really matter for our example),
perhaps it saves the input to a database, or calls an internal API.

Now you want to enforce that, before being called, the input has been validated.

And maybe you also don't want to waste CPU cycles (let's assume the process of validating is expensive)
so you want to ensure that the validation happens only once, what would you do?

Let's start with a few definitions

\begin{code}
class Data<M> {
  private readonly M!: M
  constructor(readonly input: string) {}
}
\end{code}

The \texttt{Data} class looks strange since at first it seems the type parameter is unused and could be anything,
without affecting the value inside. Indeed, one can write

\begin{code}
const changeType = <A, B>(data: Data<A>): Data<B> =>
  new Data(data.input)
\end{code}

to change it from any type to any other.

However, if the constructor is not exported then users of the library that defined \texttt{Data} can't define functions like the above,
so the type parameter can only be set or changed by library functions.

So we might do

\begin{code}
export type Unvalidated = "Unvalidated"
export type Validated = "Validated"
export type State = Unvalidated | Validated

const isNonEmptyString = (s: string): boolean => s.length > 0

export class Data<M extends State> {
  private readonly M!: M
  private constructor(readonly input: string) {}

  /**
   * since we don't export the constructor itself,
   * users with a string can only create Unvalidated values
   */
  static make(input: string): Data<Unvalidated> {
    return new Data(input)
  }

  /**
   * returns none if the data doesn't validate
   */
  static validate(
    data: Data<Unvalidated>
  ): Option<Data<Validated>> {
    return isNonEmptyString(data.input)
      ? some(new Data(data.input))
      : none
  }
}

/**
 * can only be fed the result of a call to validate!
 */
export function use(data: Data<Validated>): void {
  console.log("using " +  data.input)
}
\end{code}

Now let's try to use the library incorrectly

\begin{code}
import { Data, use } from './data'

const data = Data.make("hello")

use(data) // called without validating the input
\end{code}

If you run TypeScript you get the following error

\begin{code}
[ts]
Argument of type 'Data<"Unvalidated">' is not assignable
  to parameter of type 'Data<"Validated">'.
  Type '"Unvalidated"' is not assignable to type '"Validated"'.
\end{code}

If you call \texttt{validate} instead

\begin{code}
const data = Data.make("hello")
Data.validate(data).map(use)
\end{code}

everything is fine.

The beauty of this is that we can define functions that work on all kinds of \texttt{Data},
but still can't turn unvalidated data into validated data

\begin{code}
static toUpperCase<M extends State>(data: Data<M>): Data<M> {
  return new Data(data.input.toUpperCase())
}
\end{code}

One last thing, what happens if you try to validate the input \textbf{twice}?

\begin{code}
const data = Data.make('hello')
Data.validate(data).chain(validated =>
  Data.validate(validated)
)
\end{code}

TypeScript complains!

\begin{code}
[ts]
Argument of type 'Data<"Validated">' is not assignable
  to parameter of type 'Data<"Unvalidated">'.
  Type '"Validated"' is not assignable to type '"Unvalidated"'.
\end{code}

This technique is perfect for validating user input to a web application.
We can ensure \textbf{with almost zero overhead} that the data is validated \textbf{once and only once} everywhere that it needs to be,
or else we get a compile-time error.

\subsection{Finite state machines}

Vediamo come i phantom type possano essere sfruttati per definire una macchina a stati finiti.

\begin{example}
Modellare la seguente macchina a stati finiti (operazioni su una \texttt{Door}), mantenendo il conteggio delle
volte in cui il campanello è stato suonato

\[
\xymatrixrowsep{3cm}
\xymatrixcolsep{3cm}
\xymatrix{
  Closed \ar@/_0.5cm/[r]_{\texttt{open}} \ar@(ul,ur)^{\texttt{ring}} & Open \ar@/_0.5cm/[l]_{\texttt{close}} \\
}
\]

L'implementazione si basa su questi due principi

\begin{itemize}
\item gli stati sono rappresentati da una struttura dati \texttt{Door} contenente il conteggio e una indicazione dello stato corrente
\item le transizioni sono rappresentate da funzioni
\end{itemize}

\begin{code}
type Open = 'Open'
type Closed = 'Closed'
type State = Open | Closed

class Door<S extends State> {
  private readonly S!: S
  constructor(readonly count: number) {}
}

const start = (): Door<Closed> => new Door(0)
\end{code}

Ora definiamo una operazione per ogni arco del grafo

\begin{code}
const close = (door: Door<Open>): Door<Closed> =>
  new Door(door.count)

const open = (door: Door<Closed>): Door<Open> =>
  new Door(door.count)

const ring = (door: Door<Closed>): Door<Closed> =>
  new Door(door.count + 1)
\end{code}

La corretta successione delle operazioni ora è assicurata staticamente

\begin{code}
close(start()) // error

ring(open(start())) // error

open(ring(close(open(ring(start()))))) // ok
\end{code}
\end{example}

\begin{example}
Volendo le operazioni possono anche essere definite come metodi, il che rende più comodo concatenarle.

Per farlo possiamo sfruttare la possibilità di annotare \texttt{this}.

Inoltre posso imporre uno stato iniziale rendendo il costruttore privato

\begin{code}
class Door<S extends State> {
  private readonly S!: S
  static start(): Door<Closed> {
    return new Door(0)
  }
  private constructor(readonly count: number) {}
  open(this: Door<Closed>): Door<Open> {
    return new Door(this.count)
  }
  close(this: Door<Open>): Door<Closed> {
    return new Door(this.count)
  }
  ring(this: Door<Closed>): Door<Closed> {
    return new Door(this.count + 1)
  }
}
\end{code}

Ancora una volta la corretta successione delle operazioni è assicurata staticamente

\begin{code}
Door.start().close() // error

Door.start()
  .open()
  .ring() // error

Door.start()
  .ring()
  .open()
  .close()
  .ring()
  .open() // ok
\end{code}

Posso anche richiedere un esplicito stato finale

\begin{code}
const x: Door<Closed> = Door.start()
  .ring()
  .open() // error
const y: Door<Closed> = Door.start()
  .ring()
  .open()
  .close() // ok
\end{code}
\end{example}

\begin{exercise}
Modellare la seguente macchina a stati finiti (ciclo di vita di una \texttt{Response} di \texttt{express})

\[
\xymatrixrowsep{3cm}
\xymatrixcolsep{3cm}
\xymatrix{
  StatusOpen \ar[r]^{\texttt{status}} & HeadersOpen \ar@(ul,ur)^{\texttt{headers}} \ar[d]^{\texttt{closeHeaders}} \\
  ResponseEnded & BodyOpen \ar[l]^{\texttt{send}} \\
}
\]

L'obbiettivo principale è evitare staticamente che vengano aggiunti degli header una volta che si è mandato il body.
\end{exercise}

\begin{exercise}
Rendere type-safe il metodo \texttt{status} di \texttt{Middleware}
\end{exercise}

\subsection{Un \texttt{EventEmitter} type-safe}

Supponiamo di dover modellare un \texttt{EventEmitter}

\begin{code}
interface EventEmitter {
  emit: (name: string, data: any) => void
  listen: (name: string, handler: (data: any) => void) => void
}
\end{code}

Questo modello è insoddisfacente

\begin{itemize}
  \item non c'è relazione tra l'evento e i dati associati
  \item non c'è relazione tra l'evento e il relativo listener
\end{itemize}

Si può rimediare definendo un phantom type \texttt{Event} che immagazzina il tipo di dato relativo ad un evento

\begin{code}
class Event<D> {
  private readonly D!: D
  constructor(readonly name: string) {}
}

const evt1 = new Event<string>('evt1')
const evt2 = new Event<number>('evt2')

interface EventEmitter {
  emit: <D>(evt: Event<D>, data: D) => void
  listen: <D>(
    evt: Event<D>,
    handler: (data: D) => void
  ) => void
}

declare const ee: EventEmitter

ee.emit(evt1, "foo") // ok
ee.emit(evt1, 1) // static error
ee.emit(evt2, 1) // ok

ee.listen(evt1, data => console.log(data.trim()))
ee.listen(evt2, data => console.log(data * 2))
\end{code}

\subsection{Estrarre i tipi da mappe eterogenee}

I phantom type sono utili anche per manipolare mappe i cui valori sono di tipo eterogeneo

\begin{code}
type EventMap = { [key: string]: Event<unknown> }

const map = {
  evt1,
  evt2
}

type Handlers<EM extends EventMap> = {
  [K in keyof EM]: (data: EM[K]["D"]) => void
}
\end{code}

Si noti che per poter accedere al campo \texttt{D} devo modificare la sua visibilità nella definizione di \texttt{Event}

\begin{code}
class Event<D> {
  readonly D!: D // non più privato
  constructor(readonly name: string) {}
}
\end{code}

I tipi dei diversi eventi possono ora essere estratti in modo indipendente

\begin{code}
type MyHandlers = Handlers<typeof map>
/* same as
type MyHandlers = {
    evt1: (data: string) => void;
    evt2: (data: number) => void;
}
*/
\end{code}

\newpage
\section{Newtypes}

Non sempre i tipi predefiniti, in particolare quelli primitivi, riescono a modellare in modo soddisfacente un sistema,
si consideri la seguente funzione

\begin{code}
declare function getPost(a: string, b: string): string
\end{code}

Cosa sono \texttt{a} e \texttt{b}? Usiamo dei nomi più parlanti per gli argomenti

\begin{code}
declare function getPost(
  postId: string,
  facebookToken: string
): string
\end{code}

e anche per i tipi

\begin{code}
type PostId = string
type FacebookToken = string
type PostContents = string

declare function getPost(
  postId: PostId,
  facebookToken: FacebookToken
): PostContents
\end{code}

ma il type system vede ancora \texttt{(string, string) -> string} (e anche voi in VSCode),

Posso per errore scambiare l'ordine di \texttt{PostId} e \texttt{FacebookToken} essendo tutte e due stringhe, il type checker non mi avverte.

Un altro esempio tipico sono i valori espressi in una qualche unità di misura

\begin{code}
type Celsius = number
type Fahrenheit = number

const celsius2fahrenheit = (celsius: Celsius): Fahrenheit =>
  celsius * 1.8 + 32

const cel: Celsius = 1

celsius2fahrenheit(cel)

const far: Fahrenheit = 33.8

celsius2fahrenheit(far) // oops...
\end{code}

I type alias danno qualche beneficio in termini di documentazione ma non offrono nessun vantaggio dal punto di vista della type safety.

\begin{quote}
A common programming practice is to define a type whose representation is identical to an existing one but which
has a separate identity in the type system.
\end{quote}

Tali tipi sono comunemente chiamati \emph{newtype}.

\subsection{Phantom type wrapper}

Come abbiamo già visto una possibile soluzione è quella di creare dei wrapper simulando i tipi nominali

\begin{code}
class Newtype<M, A> {
  private readonly M!: M
  constructor(readonly value: A) {}
}

class Celsius extends Newtype<"Celsius", number> {}
class Fahrenheit extends Newtype<"Fahrenheit", number> {}

const celsius2fahrenheit = (celsius: Celsius): Fahrenheit =>
  new Fahrenheit(celsius.value * 1.8 + 32)

const far = new Fahrenheit(33.8)

celsius2fahrenheit(far)
// static error: Type '"Fahrenheit"' is not assignable
// to type '"Celsius"'
\end{code}

Un "vero" \textbf{newtype} tuttavia ha la caratteristica di \emph{non modificare la rappresentazione a runtime} cosa che chiaramente
non succede con un wrapper. È possibile implementare in TypeScript un nozione equivalente?

\subsection{Implementazione tramite \texttt{Iso}}

Dato che un newtype \texttt{S} basato su tipo \texttt{A} è \emph{isomorfo} ad \texttt{A} possiamo usare un
\texttt{Iso} per passare da uno all'altro.

\begin{code}
interface Newtype<M, A> {
  readonly M: M
  readonly A: A
}

const unsafeCoerce = <A, B>(a: A): B => a as any

const anyIso = new Iso<any, any>(unsafeCoerce, unsafeCoerce)

const iso = <S extends Newtype<any, any>>(): Iso<
  S,
  S["A"]
> => anyIso

interface Celsius extends Newtype<"Celsius", number> {}
const celsiusIso = iso<Celsius>()

interface Fahrenheit extends Newtype<"Fahrenheit", number> {}
const fahrenheitIso = iso<Fahrenheit>()

const celsius2fahrenheit = (celsius: Celsius): Fahrenheit =>
  fahrenheitIso.wrap(celsiusIso.unwrap(celsius) * 1.8 + 32)

const far: Fahrenheit = fahrenheitIso.from(33.8)

celsius2fahrenheit(far)
// static error: Type '"Fahrenheit"' is not
// assignable to type '"Celsius"'
\end{code}

Sfruttando il subtyping è possible codificare comportamenti interessanti

\begin{code}
interface NonZero
  extends Newtype<
      { readonly NonZero: unique symbol },
      number
    > {}

interface Positive
  extends Newtype<
      NonZero['M'] & {
        readonly Positive: unique symbol
      },
      number
    > {}

declare function inverse(nz: NonZero): NonZero
declare function mult(a: Positive, b: Positive): Positive

declare const nonZero: NonZero
declare const positive: Positive

inverse(nonZero) // ok
inverse(positive) // ok
mult(positive, nonZero)
// error: Property 'Positive' is missing
// in type '{ readonly NonZero: unique symbol; }'
\end{code}

\begin{exercise}
Definire \texttt{Integer} e \texttt{PositiveInteger}
\end{exercise}

\begin{exercise}
È possibile definire un \texttt{Iso} per \texttt{Positive}?
\end{exercise}

\begin{exercise}
Definire delle funzioni di conversione tra \texttt{number} e il \emph{raffinamento} \texttt{Positive}
\end{exercise}

\newpage
\section{Validazione a runtime}

TypeScript ci aiuta ad avere type safety all'interno del sistema ma alla sua frontiera occorre validare i dati in ingresso.
Scrivere manualmente le validazioni è noioso e prono ad errori, vediamo una soluzione più economica:
definire un runtime type system che collabori con lo static type system.

\begin{boxed}
live coding...
\end{boxed}

\newpage
\section{Covarianza e controvarianza}

TypeScript 2.6 ha introdotto un nuovo flag \texttt{strictFunctionTypes} (contenuto nel gruppo \texttt{strict})
che abilita il controllo della \emph{varianza} sulle funzioni.

È perciò necessario capire cosa sia la varianza e come questa influisce sul design delle API e suigli errori che il compilatore può emettere.

\begin{definition}
Within the type system of a programming language, a typing rule or a type constructor \texttt{T} is:
\begin{itemize}
\item \emph{covariant} if it preserves the ordering of types ($\leq$), which orders types from more specific to more generic
\item \emph{contravariant} if it reverses this ordering
\item \emph{bivariant} if both of these apply (i.e., both \texttt{T<A> $\leq$ T<B>} and \texttt{T<B> $\leq$ T<A>} at the same time)
\item \emph{invariant} if neither of these applies
\end{itemize}
\end{definition}

\subsection{Array}

In teoria

\begin{itemize}
  \item Read-only data types (sources) can be covariant
  \item write-only data types (sinks) can be contravariant
  \item Mutable data types which act as both sources and sinks should be invariant.
\end{itemize}

In TypeScript gli array invece sono \textbf{covarianti}, ovvero

\texttt{Array<A> $\leq$ Array<B>} se \texttt{A $\leq$ B}

\begin{code}
const xs: Array<number> = [1, 2, 3]
const ys: Array<number | undefined> = xs // ok
\end{code}

Attenzione però, questo comportamento è \emph{sound} solo se gli array sono \textbf{immutabili}

\begin{code}
ys.push(undefined) // ok :(
\end{code}

\subsection{Functions}

Le funzioni sono \textbf{controvarianti} in input e \textbf{covarianti} in output, ovvero

\texttt{(a:A) => B $\geq$ (c:C) => D} se \texttt{A $\leq$ C} e \texttt{D $\leq$ B}

\[
\xymatrixrowsep{3cm}
\xymatrixcolsep{8cm}
\xymatrix{
  C \ar[rdd] \\
  A \ar[r] & B \\
    & D \\
}
\]


\end{document}
